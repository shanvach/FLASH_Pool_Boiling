#!/usr/bin/env python

#FIXME move imports to where they're needed?
import os, sys, string, re, time, shutil, UserDict, types, glob, socket, math

#  ThisIsAClass
#  thisIsAFunction
#  use GVars.out for output, not print
#  use `raise setupError('blah blah ... error message')` to abort

class SetupError(Exception):
    pass

class EmptyClass:
    pass

def printMemUsageGuess(configInfo, opts):
    SIZEOFDOUBLE = 8 #fixme?
    nvar= configInfo['nvar']
    maxblocks = opts.maxblocks
    nb = [opts.nxb, opts.nyb, opts.nzb]
    for d in range(3):
        if d<opts.dimension: nb[d] = nb[d]+ 2*configInfo['GUARDCELLS']
    ncells = nvar * maxblocks * nb[0] * nb[1] * nb[2]    
    mem = int(math.ceil(SIZEOFDOUBLE*ncells/(1024.*1024)))
    print 'Estimated memory requirement per node: '\
          '%d*%d*%d*%d*%d = = %d cells = %d MB'% \
          (maxblocks, nvar, nb[0], nb[1], nb[2], ncells, mem)
    
def applyFlashStack():
    #we are in object directory
    GVars.out.put('running experimental FlashStack.py on sources in object'\
                  ' directory')
    cmd = os.path.join(GVars.flashHomeDir, 'tools/scripts/FlashStack.py')
    cmd = cmd + ' patch'
    os.system(cmd)
 
def generateParameterCommentList(units):
    out = IndentedOutput(4, open('paramFile.txt', 'w'))    
    for unit in units:
        if not unit['PARAMETER']: continue
        out.put(unit.name)
        out.push()
        
        pars = unit['PARAMETER'].keys()
        pars.sort()
        for par in pars:
            out.put('%s [%s]'% (par, unit['PARAMETER'][par][1]))
            out.push()
            if unit['D'].has_key(par):
                out.put(unit['D'][par])
            out.pop()
        out.pop()
    out.file.close()



def generateGridDefines(configInfo, opts):
    """ Flash.h """
    

    FILE1 = 'Flash.h'	

    GVars.out.put('writing ' + FILE1)
    

    file = open(FILE1, 'w')
    file.write("""#if 0
  File:       Flash.h, generated by setup script
  Contains:   problem dependent parameters, specified at compilation time
              Do not edit!  See problem config file.

#endif

"""
               )

    
    writeDefines(file, configInfo['variables'], "VAR")
    
    writeDefines(file, configInfo['FLUX'], "FLUX")

    writeDefines(file, configInfo['intproperty'], "PART_INT_PROP_NAMES")

    writeDefines(file, configInfo['GRIDVAR'], "SAVED_GRID_VAR")

    if configInfo['PROPERTY']:
        writeDefines(file, configInfo['realproperty'], "PART_REAL_PROP_NAMES")


    
    file.write("\n#define NDIM " + str(opts.dimension))	
    file.write("\n#define NXB " + str(opts.nxb))	
    file.write("\n#define NYB " + str(opts.nyb))	
    file.write("\n#define NZB " + str(opts.nzb))	
    file.write("\n#define MAXBLOCKS " + str(opts.maxblocks))	


    grid_vars = len(configInfo['GRIDVAR'])

    unk_vars = len(configInfo['variables']) + configInfo['NUMSPECIES'] + configInfo['NUMMASSSCALARS']

    nvar = len(configInfo['variables'])
    
    flux_vars = len(configInfo['FLUX']) + 1
    
    if nvar == 0:
        nvar = 1

    file.write("\n#define UNK_VARS " + str(unk_vars))
    file.write("\n#define FLUX_VARS " + str(flux_vars))    
    file.write("\n#define NUM_SAVED_GRID_VARS " + str(grid_vars))

    file.write("\n#define NVAR_NAMED " + str(nvar))
    file.write("\n#define NGUARD " + str(configInfo['GUARDCELLS']))
    file.write("\n#define NFLUX_NAMED " + str(len(configInfo['FLUX'])))	
    file.write("\n#define NSPECIES " + str(configInfo['NUMSPECIES']))	
    file.write("\n#define NMASS_SCALARS " + str(configInfo['NUMMASSSCALARS']))


    file.write("\n#define NFLUX_SPECIES 1")
    
    iNuc_begin = nvar + 1
    
    file.write("\n#define INUC_BEGIN " + str(iNuc_begin))	
    file.write("\n#define INUCFLX_BEGIN " + str(len(configInfo['FLUX'])+1))	


    # rename for shorter names
    k1d = 1
    k2d = opts.dimension/2
    k3d = (opts.dimension -1)/2
    nguard = configInfo['GUARDCELLS']

    file.write("\n\n#define K1D 1")	
    file.write("\n#define K2D " + str(k2d))	
    file.write("\n#define K3D " + str(k3d))	

    file.write("\n\n#define GRID_ILO_GC 1")	
    file.write("\n#define GRID_JLO_GC 1")	
    file.write("\n#define GRID_KLO_GC 1")	

    file.write("\n\n#define GRID_IHI_GC " + str(opts.nxb+2*nguard))	
    file.write("\n#define GRID_JHI_GC " + str(opts.nyb+2*nguard*k2d))
    file.write("\n#define GRID_KHI_GC " + str(opts.nzb+2*nguard*k3d))

    maxcells = max((opts.nxb + 2*nguard),(opts.nyb+2*nguard*k2d),(opts.nzb+2*nguard*k3d))
    
    
    file.write("\n\n#define MAXCELLS " + str(maxcells))	

    file.write("\n\n#define GRID_ILO " + str(nguard + 1))	
    file.write("\n#define GRID_JLO " + str(nguard*k2d + 1))	
    file.write("\n#define GRID_KLO " + str(nguard*k3d + 1))	

    file.write("\n\n#define GRID_IHI " + str(nguard + opts.nxb))	
    file.write("\n#define GRID_JHI " + str(nguard*k2d + opts.nyb))	
    file.write("\n#define GRID_KHI " + str(nguard*k3d + opts.nzb))	

    #file.write("\n#define IPT 4 ")	

    file.write("\n#define LEAF 1")
    file.write("\n#define PARENT 2")
    file.write("\n#define ANCESTOR 3")

    file.write("\n#define WILDCARD -1")

    if opts.fixedBlockSize == 1:
        file.write("\n#define FIXEDBLOCKSIZE 1")


    #file.write("\n\n#define REAL_FORMAT \"(ES20.13)\"\n")

    file.write("\n\n")	

    file.close()




def writeDefines(file, list, strname):
     for i in range(len(list)):
	up_str = string.upper(list[i])
	file.write("#define " + up_str + "_" + strname + " " + str(i+1) + "\n")	

def writeSimulation_mapVarToString(configInfo, opts):
    ## This is a function that maps a variable enumerated
    ## constant back to a string.
    ## This function is useful with IO so we know
    ## which variables we are outputing in terms of a string
    ## rather than a number

    FILE1 = 'Simulation_mapVarToString.F90'	

    GVars.out.put('writing ' + FILE1)
    

    file = open(FILE1, 'w')
    file.write("!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n")
    file.write("!! File created at setup time.  DO NOT EDIT !!!\n\n")

    file.write("subroutine Simulation_mapVarToString(key, str)\n\n")
    #file.write("#include \"constants.h\"\n"); 
    file.write("   integer, intent(in) :: key\n")
    file.write("   character(len=4), intent(inout) :: str\n")


        
    ## write a case statement for all the VARS
    file.write("   select case (key)\n");
    for i in range(len(configInfo['variables'])):
        file.write("   case (" + str(i+1) + ")\n")
        file.write("      str = \"" + str(configInfo['variables'][i]) + "\"\n\n")

    file.write("   case DEFAULT\n")
    file.write("      str = \"blah\"\n\n")
    file.write("   end select\n")
    file.write("   return\n")

    file.write("\nend subroutine Simulation_mapVarToString\n")    
    file.close()


#This routine is never called
def generateDbaseDefines(configInfo, opts):
    """ create flash_defines.fh and dbase_defines.fh"""
    FILE1 = 'dbase_defines.fh'	
    FILE2 = 'flash_defines.fh'

    GVars.out.put('writing ' + FILE1)

    file = open(FILE1, 'w')
    file.write("""#if 0
  File:       dbase_defines.fh, generated by setup script
  
  Contains:   problem dependent parameters, specified at compilation time
  
              Do not edit!  See problem config file.

#endif

"""
               )

    file.write(macroList('#define DBASE_VAR_NAMES',
                         configInfo['variables']))
    
    if configInfo['FLUX']:
        file.write('\n')
        file.write(macroList('#define DBASE_FLUX_NAMES',
                             configInfo['FLUX']))

    if configInfo['PROPERTY']:
        if configInfo['intproperty']:
            file.write('\n')
            file.write(macroList('#define DBASE_PART_INT_PROP_NAMES',
                                 configInfo['intproperty']))
        if configInfo['realproperty']:
            file.write('\n')
            file.write(macroList('#define DBASE_PART_REAL_PROP_NAMES',
                                 configInfo['realproperty']))

    file.write('\n')
    file.write(macroList('#define DBASE_VAR_ADVECT',
                         configInfo['var_advect_str']))
    file.write('\n')
    file.write(macroList('#define DBASE_VAR_RENORM',
                         configInfo['var_renorm_str']))
    file.write('\n')
    file.write(macroList('#define DBASE_VAR_CONSERVE',
                         configInfo['var_conserve_str']))
        
    file.write("""
#define DBASE_NUMBER_OF_ADVECT_VARIABLES %(nvar_advect)d
#define DBASE_NUMBER_OF_RENORM_VARIABLES %(nvar_renorm)d
#define DBASE_NUMBER_OF_CONSERVE_VARIABLES %(nvar_conserve)d
#define DBASE_NUMBER_OF_SPECIES %(NUMSPECIES)d
#define DBASE_NUMBER_OF_MASS_SCALARS %(NUMMASSSCALARS)d
""" % configInfo
               )

    file.close()

    # write global defines file
    GVars.out.put('writing ' + FILE2)
    file = open(FILE2, 'w')
    file.write("""#if 0
File:       flash-defines.fh, generated by setup script

Contains:   problem dependent parameters, specified at compilation time

Do not edit!  See problem config file.
#endif

#ifndef FLASH_DEFINES_INCLUDED
#define FLASH_DEFINES_INCLUDED

#define FLASH_NUMBER_OF_VARIABLES %(nvar)d
#define FLASH_NUMBER_OF_FLUXES %(nflux)d
#define FLASH_NUMBER_OF_GUARD_CELLS %(GUARDCELLS)d
#define FLASH_NUMBER_OF_INT_PARTICLE_PROPS %(n_int_props)d
#define FLASH_NUMBER_OF_REAL_PARTICLE_PROPS %(n_real_props)d

#define MAX_STRING_LENGTH 80

#define REAL_FORMAT "(ES20.13)"
""" % configInfo)
    
    if opts.npg == 1:
        file.write("#define NO_PERMANENT_GUARDCELLS\n\n")
    file.write("#endif\n\n\n")
    file.close()




def generateMakefile(configInfo, opts, machDir):
    TEMPLATE="""#  Makefile for FLASH code.  Automatically generated by setup script.
#  Do not edit!

EXE = flash3

default : $(EXE)

#\tMachine-dependent include file

CDEFINES = %(cDefines)s
FDEFINES = %(fDefines)s

#\tprint the compiler flags to file in FLASH/object/
#\t(files name are also hard-coded into source/util/tools/compiler_flags.c)
PRINT_F_FLAGS = $(ECHO) $(FCOMP) $(FFLAGS) $(FDEFINES) > f_compiler_flags
PRINT_C_FLAGS = $(ECHO) $(CCOMP) $(CFLAGS) $(CDEFINES) > c_compiler_flags


include Makefile.h

%(flagRedirect)s

#\tCompile



.SUFFIXES:

.SUFFIXES: .f .F .f90 .F90 .c .C .o
  
.f.o :
\t$(FCOMP) $(FFLAGS) $(FDEFINES) $*.f
.F.o :
\t$(FCOMP) $(FFLAGS) $(FDEFINES) $*.F
.f90.o :
\t$(FCOMP) $(FFLAGS) $(f90FLAGS) $(FDEFINES) $*.f90
.F90.o :
\t$(FCOMP) $(FFLAGS) $(F90FLAGS) $(FDEFINES) $*.F90
.c.o :
\t$(CCOMP) $(CFLAGS) $(CDEFINES) $*.c
.C.o :
\t$(CPPCOMP) $(CFLAGS) $(CDEFINES) $*.C
%%API.c %%API.h %%API-bridges.F90: %%.int
\t./int2API.py $<

.PRECIOUS: %%API.c %%API.h %%API-bridges.F90

# Note, the tmpfiles are needed to ensure that the following routines
# get recompiled every time.  Parallel builds (e.g. gmake -j 4) complicate
# this process, by requiring that the source (e.g. buildstamp.f) is generated
# by the same set of rules (and therefore same process) as the object file

#       Buildstamp routine

buildstamp.o : .buildstamp_tmpfile
\t./make_bstamp
\t$(FCOMP) $(FFLAGS) buildstamp.f
#\t$(RM) buildstamp.f
\t$(RM) .buildstamp_tmpfile

.buildstamp_tmpfile :
\ttouch .buildstamp_tmpfile


#       Release routine

flash_release.o : .flash_release_tmpfile
\t./make_release
\t$(FCOMP) $(FFLAGS) flash_release.f
\t$(RM) flash_release.f
\t$(RM) .flash_release_tmpfile

.flash_release_tmpfile :
\ttouch .flash_release_tmpfile

#       Build statistics routine

buildstats.o : .buildstats_tmpfile
\t$(PRINT_F_FLAGS)
\t$(PRINT_C_FLAGS)
\t./make_bstats
\t$(FCOMP) $(FFLAGS) $(F90FLAGS) buildstats.F90
\t$(RM) buildstats.F90
\t$(RM) .buildstats_tmpfile

.buildstats_tmpfile :
\ttouch .buildstats_tmpfile


#       FLASH Units routine

flashUnits.o : 
\t./make_flashUnits
\t$(FCOMP) $(FFLAGS) $(F90FLAGS) flashUnits.F90
\t$(RM) flashUnits.F90


#\tUnit Makefiles

%(includeList)s
UNITS = \\%(includeMacros)s
       $(MACHOBJ) buildstamp.o flash_release.o buildstats.o flashUnits.o %(flash_stack)s

#\tLink

$(EXE) : $(UNITS)
\t$(LINK) $(LFLAGS) $(EXE) $(UNITS) $(LIB) $(CONFIG_LIB)
\t$(ECHO) SUCCESS

#\tClean up object directory

clean :
\t$(RM) *.o *.a *.unit *API.h *API.c *API-bridges.F90

precision_test : precision_test.o
\t$(LINK) $(LFLAGS) precision_test precision_test.o
"""    
    flagRedirect = setRedirectFlags('Makefile.h', opts.buildFlag,
                                    configInfo['LIBRARY'])

    fDefines = ''
    cDefines = ''
    for define in opts.defines:
        fDefines = fDefines + '$(MDEFS)%s '% define
        cDefines = cDefines + ' ' + define
        
    makefiles = glob.glob('Makefile.*')
    #FIXME remove this once all those makefile dependencies are fixed.
    makefiles.sort()
   

    if 'Makefile.h' in makefiles: makefiles.remove('Makefile.h')
    includeList = ''
    includeMacros = ''
    for file in makefiles:
        unit = os.path.splitext(file)[1][1:]
        includeList = includeList + 'include %s\n'%file
        includeMacros = includeMacros + '\n       $(%s) \\'%unit

    flash_stack = ''
    if opts.flashStack:
        flash_stack = 'flash_stack.o'

    file = open('Makefile', 'w')
    file.write(TEMPLATE%locals())
    file.close()



class outputParameterInfo:
    def write(self):
        f = open(self.rt_initFile, 'w')
        f.write(self.rt_init1 + '\nreturn\nend\n')
        f.close()

        
    def __init__(self, units):
        """Write info related to Config files' PARAMETERs to various files in
        dir
        """
        self.rt_initFile = 'Setup_initParms.F90'

        self.rt_init1 = '! Runtime-settable parameter initializations;\n'\
                        '! generated by setup script.\n'\
                        '! Do not edit!\n\n'\
                        'subroutine Setup_initParms(parmfile)\n\n'\
                        'character(len=*) :: parmfile\n\n'\
                        'call Setup_createParms()\n'\
                        'call RuntimeInputs_readParms(parmfile)\n'\
                        'return\n'\
                        'end\n\n\n'\
                        'subroutine Setup_createParms()\n\n'\
                        '#include "constants.h"\n'\
                        'use RuntimeInputs_data\n\n'\
                        'implicit none\n\n'

        


        self.checkForDuplicates(units)        
        self.processUnits(units)
        self.write()

    def checkForDuplicates(self, units):
        #check that no two parameters have the same name, print warning if
        #they do
        GVars.out.push()
        for unit1 in units:
            for unit2 in units:
                if unit1>=unit2: continue
                for p1 in unit1['PARAMETER'].keys():
                    for p2 in unit2['PARAMETER'].keys():
                        if string.lower(p1) == string.lower(p2): #fixme (the lowering should be done at parser level)
                            GVars.out.put('WARNING: Parameter %s defined in'\
                                          ' both\n%s\nand\n%s\nIgnoring'\
                                          ' first instance.\n'%(p1, unit1,
                                                                unit2))
                            #if unit1 and unit2 are parent and child, we want to drop the parent (maybe shouldn't print warning in that case)
                            del unit1['PARAMETER'][p1]
                            
        GVars.out.pop()
                       
    def processUnits(self, units):
        DECLMAP = {'REAL': 'real',
                   'INTEGER': 'integer',
                   'STRING':  'character(len=MAX_STRING_LENGTH)',
                   'BOOLEAN':'logical'}
        
        for unit in units:
            for pName in unit['PARAMETER'].keys():
                pType, pValue, pConst = unit['PARAMETER'][pName][:]
                if pType=='BOOLEAN': pValue = '.%s.'%pValue

                if pConst:
                    self.rt_init1= self.rt_init1+\
                           '  call RuntimeInputs_addParm('\
                           ' "%s", %s, %s)\n'%(pName, pValue, "TYPE_CONST")
                else:
                    self.rt_init1= self.rt_init1+\
                           '  call RuntimeInputs_addParm('\
                           ' "%s", %s)\n'%(pName, pValue)



                
def checkRequirements(units):
    for unit in units:
        for req in unit['REQUIRES']:
            good = 0
            for requnit in req:
                if requnit in units:
                    good = 1
            if not good:
                raise SetupError('%s REQUIRES %s, not included'%(unit.name,
                                 string.replace(`req`[1:-1], ',', ' OR')))
                                                                             
def addTopUnits(units, sourceDir='.'):
    """If a top level unit isn't in units, add it, and add it's null
    directory if it has one.  A top level unit is defined as the highest
    level capital letter directory.  Lower case directory names are just
    organizational, for example, source/physics.  We really want to include
    the stub for source/physics/Hydro/ , source/physics/Gravity etc.
    In this case the Gravity and Hydro units are the top level units even
    though they are under the organizational directory physics

    NOTE: we ignore Config files FIXME (not in documentation)"""


    
        
    NULLUNIT = 'null'
    topUnits = os.listdir(sourceDir)
    for dir in ['CVS', 'sites']:
         if dir in topUnits: topUnits.remove(dir)
        
    # check topUnits, if they are just organizational directories,
    # go down one level and get the real top level Units

    
    lowerUnits = []
    removeList = []
 
    for unit in topUnits:
        if not (is_upper(unit[0])):
            #print unit
            nextLevel = os.path.join(sourceDir, unit)
            nextLevelUnits = os.listdir(nextLevel)
            #print "nextlevelUnits are " + str(nextLevelUnits)
            #I think this is bad now, but we'll test it on other simulations
            for un in nextLevelUnits:
                if un == 'CVS' or 'DummyMPI':
                    continue
                if (is_upper(un[0])):
                    nextLevelFullPathUnit = os.path.join(nextLevel, un)
                    #print 'appending ' + nextLevelFullPathUnit
                    if nextLevelFullPathUnit not in lowerUnits:
                        lowerUnits.append(nextLevelFullPathUnit)
            #            #lowerUnits.append(os.path.join(nextLevel, un))
            removeList.append(unit)


    topUnits = topUnits + lowerUnits        

    for dir in removeList:
         if dir in topUnits: topUnits.remove(dir)
            

    #print "printing topUnits"
    print topUnits
        
    for unit in topUnits:
        if unit not in units:
            units.append(FlashUnit(unit, ignoreConfig=1))
            if os.path.isdir(os.path.join(unit, NULLUNIT)):
                units.append(FlashUnit(os.path.join(unit, NULLUNIT),
                                          ignoreConfig=1))

    
    return units

def is_upper(letter):
    a = string.upper(letter)
    if a == letter:
        return 1
    else:
        return 0


    
def checkExclusivity(units):
    #units contains everybody's parents
    for unit in units:
        for group in unit['EXCLUSIVE']:
            #No two elements of group must be in units
            a=None
            for b in group:
                if b not in units: continue
                if a: raise SetupError('%s and %s are exclusive'%(a, b))
                a=b
                                     

def checkConflicts(units):
    for unit in units:
        for group in unit['CONFLICTS']:
            for b in group:
                if b in units:
                    raise SetupError("setup Error: requested unit %s"            \
                                     " prohibited by explicit CONFLICTS statement"%(b))
            
        
def readInputUnitsFile(file, opts):
    if not os.path.isfile(file):
        raise SetupError('cannot access %s file, try using -auto'%file, 1)

    units = map(FlashUnit, opts.withUnits) #redundant if used -auto
                         
    GVars.out.put('scanning %s file for included units'%file)
    GVars.out.push()
    for line in open(file).readlines():
        rawline = line
        if string.count(line, '#'):
            line=line[:string.find(line, '#')]
        line=string.strip(line)
        if not line: continue
        try:
            a,b=string.split(line)
            if a!='INCLUDE': raise SetupError
        except (ValueError, SetupError):
            raise SetupError('Bad syntax:\n%s'%rawline)

        if b in units: continue
        units.append(FlashUnit(b))
        GVars.out.put(b)

    GVars.out.pop()
    return units
 
def stripComments(line, commentCharacter):
    #Strip comments -- FIXME: eats STRINGs
    if string.count(line, commentCharacter):
        line=line[:string.find(line, commentCharacter)]
    return line

def expandDefaultUnits(units):
    new = 1
    while new:
        new = 0
        for unit in units[:]:
            for child in unit['DEFAULT']:
                #print child
                if child not in units:
                    new = 1
                    units.append(FlashUnit(child))
    return units

def expandKernalUnits(units):
    #check to see which units are Kernal units
    #if we have a Kernal unit then we want to
    #include all units and directories under the
    #unit specified to be a Kernal
    #print "in expandKernalUnits"
  
    for unit in units:
        for group in unit['KERNAL']:
            #print group
            recursiveGetDir(group, units)
                    

    return units


def recursiveGetDir(path, units):
     
    list = os.listdir(path)
    #print list
    for file in list:
        #print "----------" + file + "-----------"
        if (string.find(file, 'CVS') == -1):
            path_a = os.path.join(path, file)
            #print path_a
            if os.path.isdir(path_a):
                #print 'found a dir ',
                if FlashUnit(path_a) not in units:
                    #print "appended the unit"
                    #print path_a
                    units.append(FlashUnit(path_a))
                recursiveGetDir(path_a, units)
    return units       


def expandParentUnits(units):
    new = 1
    while new:
        new = 0
        for unit in units[:]:
            parent = unit.getParent()
            if (parent and (parent not in units)):
                    new = 1
                    units.append(FlashUnit(parent))
    return units

class IndentedOutput:
    def __init__(self, numSpaces=4, file=None):
        self.WRAP = 80
        self.indent = 0
        self.numSpaces = numSpaces
        if not file: self.file = sys.stdout
        else: self.file = file            
    def put(self, text):        
        for line in map(string.strip, string.split(text, '\n')):
            line = ' '*self.indent*self.numSpaces + line
            more = ''
            if len(line)>self.WRAP:
                more = line[self.WRAP:]
                line = line[:self.WRAP]
            self.file.write(line+'\n')
            self.file.flush()
            if more:
                self.put(more)
    def pop(self, numLevs=1):
        """Remove numLevs indentation levels"""
        self.indent = self.indent - numLevs
        if self.indent < 0:
            raise SetupError('Popped indentation one time too many!')
    def push(self, numLevs=1):
        self.indent = self.indent + numLevs

def generateBuildstampGenerator():
    OUTFILE = 'make_bstamp'
    TEMPLATE = """#!/bin/sh -f

#\t\tScript to create a subroutine which writes a 'build stamp'
#\t\tto the log file

rm -f buildstamp.f
echo '      ' subroutine build_stamp \(s_stamp_str, b_stamp_str, str_len\) >> buildstamp.f
echo '      ' implicit none >> buildstamp.f
echo '      ' integer                  :: str_len >> buildstamp.f
echo '      ' character\(len=str_len\) :: s_stamp_str, b_stamp_str >> buildstamp.f
echo '      ' s_stamp_str = \\'%(date)s\\'  >> buildstamp.f
echo '      ' b_stamp_str = \\'`date`\\'  >> buildstamp.f
echo '      ' return >> buildstamp.f
echo '      ' end subroutine >> buildstamp.f
echo '      ' >> buildstamp.f
echo '      ' subroutine system_info \(system_str, str_len\) >> buildstamp.f
echo '      ' integer                  :: str_len >> buildstamp.f
echo '      ' character\(len=str_len\) :: system_str >> buildstamp.f
echo '      ' system_str = \\'%(uname)s\\'  >> buildstamp.f
echo '      ' return >> buildstamp.f
echo '      ' end subroutine >> buildstamp.f
echo '      ' >> buildstamp.f

"""
    date = time.asctime(time.localtime(time.time()))
#    uname = os.uname()
#    uname = '%s %s %s %s' % (uname[0], uname[1], uname[2], uname[4])
    uname = "MacOSX Darwin"
    file = open(OUTFILE, "w")
    file.write(TEMPLATE%vars())
    file.close()
    os.chmod(OUTFILE, 0744)


def removeParentUnits(units):
    units = units[:]
    for unit in units[:]:
        try: units.remove(unit.getParent())
        except ValueError: pass
    return units

def expandRequiredUnits(units):
    out = units[:]
    for unit in units:
        for reqs in unit['REQUIRES']:
            good = 0
            for req in reqs:
                if req in out:
                    good = 1
            if not good: #pick first unit in an OR list
	        if GVars.verbose:
                    GVars.out.put('%s wants %s'%(unit, reqs[0]))
		out.append(FlashUnit(reqs[0]))	
    return out
                
def generateUnitsfile(outfile, opts):
    GVars.out.push()    
    if os.path.isfile(outfile):
        GVars.out.put('renaming original to Units.bak')
        os.rename(outfile, 'Units.bak')

    outfile = open(outfile, 'w')
    outfile.write('#Units file for %s generated by setup '\
                  '-auto\n\n'%opts.simulationName)
    

    os.chdir('source')
    
    simulation=FlashUnit(os.path.join('..', 'simulations', opts.simulationName))
    units = [simulation] + map(FlashUnit, opts.withUnits)

    while 1:
        oldunits=units[:]
        oldunits
        units.sort()

        units = expandParentUnits(units)
        units = expandRequiredUnits(units)
        units = removeParentUnits(units)
        units.sort()
        if units!=oldunits:
            continue
        units = expandDefaultUnits(units)
        units = expandKernalUnits(units)
        if units==oldunits:
            break
        elif GVars.verbose: 
            GVars.out.put('Expanding defaults:') #ok, we already expanded
            GVars.out.push()
            for unit in units:
                if unit not in oldunits:
                    GVars.out.put(`unit`)
            GVars.out.pop()
            
    #We want the Units file to be concise
    units = removeParentUnits(units)
    units.remove(simulation)
    
    for unit in units:
        outfile.write('INCLUDE %s\n'%unit.name)
    outfile.close()
    
    os.chdir('..')
    GVars.out.pop()


class FlashUnit(UserDict.UserDict):
    """Encapsulates unit information as expressed in Config files.
    Data is accessed through dictionary methods, ex:

    FlashUnit('io/amr')['DEFAULT']
    FlashUnit('../simulations/sedov')['LIBRARY']

    This is where the Config file syntax is defined.
    NOTE: we need to be in source/ when instantiating this.
    """
    def __init__(self, pathname, ignoreConfig=0):
        UserDict.UserDict.__init__(self)

        self.COMMENT = '#'
        self.FILEBASE = 'Config'

        self.regexps = {}
        self.parsers = []

        
        # This is just a clever way to list the methods in the
        # class. The dir(self.__class__) lists all the attributes
        # like __cmp__ , __init___, __setitem__, __len__ etc and
        # then also the user defined methods, in this case,
        # getParent, initParser, match, parseDEFAULT, parseEXCLUSIVE etc.
        for name in dir(self.__class__):
            if not re.compile(r'parse[A-Z]+$').match(name): continue
            if type(getattr(self, name))==types.MethodType:
                self.parsers.append(name)
                try: getattr(self, name)('') #initialize regexps, dictionary
                except SetupError: pass
        

                
        if not os.path.isdir(pathname):
            raise SetupError('%s is not a valid directory'%pathname)
       
        self.name = os.path.normpath(pathname) #something like 'io/amr'

        if (not ignoreConfig) and \
          os.path.isfile(os.path.join(self.name, self.FILEBASE)):
            self.filename = os.path.join(self.name, self.FILEBASE)
            self.parse()
        else:
            self.filename = ''

            
            

    def __cmp__(self, other):
        """Alphabetical comparison on unit names (like 'source/io/amr')"""
        if type(other)==types.StringType:
            return cmp(self.name, other)
        else:
            return cmp(self.name, other.name)

    def __repr__(self):
        return self.name
        
    def getParent(self):
        """Returns parent unit's full name, empty string if we're orphans"""
        return os.path.split(self.name)[0] #FIXME ../simulations/ case
        
    def initParser(self, keyword, initvalue, regexp=None):
        if self.has_key(keyword): return
        self[keyword]=initvalue
        if regexp:
            self.regexps[keyword]=re.compile(regexp)
            #FIXME solution to STRING PARAMATER hack is to do the comment
            #stripping here by tagging on r'\s*(?:#.*)' to the regexp. No time
            #to test it so I'm not doing it now. This would help with inline
            #comments too.
            
    def match(self, keyword, line):
        match = self.regexps[keyword].match(line)
        if not match:
            raise SetupError('input doesn\'t match regular expression "%s"'%\
                             self.regexps[keyword].pattern)
        return match

    def parse(self):
        lineno = 0

        for line in open(self.filename).readlines():
            lineno = lineno + 1
            rawline = line
            if rawline and rawline[-1]=='\n': rawline = rawline[:-1]

            line=stripComments(line, self.COMMENT)
            line=string.strip(line)
            if not line: continue

            keyword = string.split(line)[0]
            if 'parse'+keyword not in self.parsers:

                raise SetupError('Unknown keyword: file %s, line '\
                                 '%d\n%s'%(self.filename, lineno, rawline))
            try:
                self.rawline = rawline #FIXME this is for STRING PARAM hack
                getattr(self, 'parse'+keyword)(line)
            except SetupError, msg:
                raise SetupError('Bad syntax: file %s, line %d:\n%s\n\n%s' % \
                                 (self.filename, lineno, rawline, str(msg)))

    def parseD(self, line):
        self.initParser('D', {}, 'D\s*(&|\S+)\s*(.*)$')
        key, comment = self.match('D', line).groups()

        if key=='&':
            try:
                self['D'][self.DKey] = self['D'][self.DKey] + ' ' + comment
            except AttributeError:
                raise SetupError('Improper usage of comment continuation')
        else:
            self.DKey = key
            self['D'][key] = comment
            
    def parseVARIABLE(self, line):
        self.initParser('VARIABLE', {},
                        'VARIABLE\s+(\w+)'
                        '(?:\s+((?:NO)?(?:ADVECT|RENORM|CONSERVE)))?'
                        '(?:\s+((?:NO)?(?:ADVECT|RENORM|CONSERVE)))?'
                        '(?:\s+((?:NO)?(?:ADVECT|RENORM|CONSERVE)))?$')
        match = self.match('VARIABLE', line)

        variable = match.group(1)
        if self['VARIABLE'].has_key(variable):
            raise SetupError('VARIABLE %s already declared'%variable)

        attributes = list(match.groups()[1:]) #Generally contains Nones
        attributes.sort()
        self['VARIABLE'][variable] = attributes

    def parseLIBRARY(self, line):
        self.initParser('LIBRARY', [], 'LIBRARY\s+(\S+)$')
        libname = self.match('LIBRARY', line).group(1)

        if libname not in self['LIBRARY']:
            self['LIBRARY'].append(libname)

    def parseGUARDCELLS(self, line):
        self.initParser('GUARDCELLS', None, r'GUARDCELLS\s+([0-9]+)$')
        num = int(self.match('GUARDCELLS', line).group(1))

        if self['GUARDCELLS']!=None:
            raise SetupError('GUARDCELLS already declared')
        self['GUARDCELLS'] = num

    def parseNUMSPECIES(self, line):
        self.initParser('NUMSPECIES', None, r'NUMSPECIES\s+([0-9]+)$')
        num = int(self.match('NUMSPECIES', line).group(1))

        if self['NUMSPECIES']!=None:
            raise SetupError('NUMSPECIES already declared')
        self['NUMSPECIES'] = num

    def parseNUMMASSSCALARS(self, line):
        self.initParser('NUMMASSSCALARS', None, r'NUMMASSSCALARS\s+([0-9]+)$')
        num = int(self.match('NUMMASSSCALARS', line).group(1))

        if self['NUMMASSSCALARS']!=None:
            raise SetupError('NUMMASSSCALARS already declared')
        self['NUMMASSSCALARS'] = num

    def parseFLUX(self, line):
        self.initParser('FLUX', [], r'FLUX\s+(\w+)$')
        flux = self.match('FLUX', line).group(1)
                
        if flux not in self['FLUX']:
            self['FLUX'].append(flux)



    def parseGRIDVAR(self, line):
        self.initParser('GRIDVAR', [], r'GRIDVAR\s+(\w+)$')
        match = self.match('GRIDVAR', line).group(1)

        if match not in self['GRIDVAR']:
            self['GRIDVAR'].append(match)



    def parsePROPERTY(self, line):
        self.initParser('PROPERTY', {}, r'PROPERTY\s+(\w+)\s+(INTEGER|REAL)$')
        name, type = self.match('PROPERTY', line).groups()

        if self['PROPERTY'].has_key(name):
            raise SetupError('PROPERTY %s already declared'%name)

        self['PROPERTY'][name] = (type)

    def parseREQUIRES(self, line):
        MAXOR = 10 #FIXME
        self.initParser('REQUIRES', [],
                        r'REQUIRES\s+(\S+)'+MAXOR*r'(?:\s+OR\s+(\S+))?'+'$')
                        
        units = list(self.match('REQUIRES', line).groups())
        while None in units: units.remove(None)
        units = map(os.path.normpath, units)

        self['REQUIRES'].append(units)

    def parsePARAMETER(self, line):
        self.initParser('PARAMETER', {}, r'PARAMETER\s+(\w+)\s+'\
                        '(INTEGER|REAL|STRING|BOOLEAN)\s+'\
                        '(?:(CONSTANT)\s+)?(.+)$')
        name, type, constant, value = self.match('PARAMETER', line).groups()
        if self['PARAMETER'].has_key(name):
            raise SetupError('%s already declared'%name)

        if type=='STRING':
            #This is a hack. I "forgot" to accomodate parsers that would need
            #rawlines when I wrote the general framework. See initParser.
            if not self.regexps.has_key('pstring'):
                self.regexps['pstring']=re.compile(r'PARAMETER\s+(\w+)\s+'\
                                                 'STRING\s+(".*")\s*(?:#.*)?$')
            name, value = self.match('pstring', self.rawline).groups()

        self['PARAMETER'][name]=(type, value, constant)

    def parseDEFAULT(self, line):
        self.initParser('DEFAULT', [], r'DEFAULT\s+(\S+)$')
        unit = os.path.normpath(self.match('DEFAULT', line).group(1))
        unit = os.path.join(self.name, unit)
        
        #A unit may define multiple defaults, they all get included
        if unit not in self['DEFAULT']:
            self['DEFAULT'].append(unit)
                                                
    def parseEXCLUSIVE(self, line):
        #print "Inside parseEXCLUSIVE!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"
        self.initParser('EXCLUSIVE', [], r'EXCLUSIVE\s+(.+)$')
        units = string.split(self.match('EXCLUSIVE', line).group(1))
        units = map(os.path.normpath, units)
        units = map(lambda x, y=self.name: os.path.join(y,x), units)
        units.sort()
        
        if units not in self['EXCLUSIVE']:
            self['EXCLUSIVE'].append(units)
            



    def parseKERNAL(self, line):
        self.initParser('KERNAL', [], r'KERNAL')
        match = self.match('KERNAL', line)

        if self.name not in self['KERNAL']:
            self['KERNAL'].append(self.name)
            


    def parseCONFLICTS(self, line):
        self.initParser('CONFLICTS', [], r'CONFLICTS\s+(.+)$')
        units = string.split(self.match('CONFLICTS', line).group(1))
#        units = map(os.path.normpath, units)
#        units = map(lambda x, y=self.name: os.path.join(y,x), units)
        units.sort()
        
        if units not in self['CONFLICTS']:
            self['CONFLICTS'].append(units)

                        

class UnitUnion(UserDict.UserDict):
    """Collates info from an ordered list of FlashUnit instances"""
    def __init__(self, units):
        UserDict.UserDict.__init__(self)
        self['FLUX'] = []
        self['VARIABLE'] = {}
        self['LIBRARY'] = []
        self['NUMSPECIES'] = None
        self['NUMMASSSCALARS'] = None
        self['GUARDCELLS'] = None
        self['PROPERTY'] = {}
        self['GRIDVAR'] = []
        
        self.collate(units)                  
        self.setDefaults()
        self.simplify()

    def collate(self, units):
     	for unit in units:
            for lib in unit['LIBRARY']:
                if lib not in self['LIBRARY']:
                    self['LIBRARY'].append(lib) 

            for grid_var in unit['GRIDVAR']:
                if grid_var not in self['GRIDVAR']:
                    self['GRIDVAR'].append(grid_var)

            for flux in unit['FLUX']:
                if flux not in self['FLUX']:
                    self['FLUX'].append(flux)

            if unit['NUMSPECIES']!=None:
                if self['NUMSPECIES']==None:
                    self['NUMSPECIES']=unit['NUMSPECIES']
                elif self['NUMSPECIES']!=unit['NUMSPECIES']:
                    raise SetupError('NUMSPECIES clash')

            if unit['NUMMASSSCALARS']!=None:
                if self['NUMMASSSCALARS']==None:
                    self['NUMMASSSCALARS']=unit['NUMMASSSCALARS']
                elif self['NUMMASSSCALARS']!=unit['NUMMASSSCALARS']:
                    raise SetupError('NUMMASSSCALARS clash')

            if unit['GUARDCELLS']!=None:
                if self['GUARDCELLS']==None:
                    self['GUARDCELLS']=unit['GUARDCELLS']
                else:
                    self['GUARDCELLS']= max(unit['GUARDCELLS'],
                                            self['GUARDCELLS'])

	
            for var in unit['VARIABLE'].keys():
		#print unit['VARIABLE'].keys()		
                if var in self['VARIABLE'].keys():
                    if unit['VARIABLE'][var]!=self['VARIABLE'][var]:
                        raise SetupError('VARIABLE mismatch')
                else:
                    self['VARIABLE'][var]=unit['VARIABLE'][var]

            for prop in unit['PROPERTY'].keys():
                if prop in self['PROPERTY'].keys():
                    if unit['PROPERTY'][prop]!=self['PROPERTY'][prop]:
                        raise SetupError('Integer/Real PROPERTY mismatch')
                else:
                    self['PROPERTY'][prop]=unit['PROPERTY'][prop]

    def setDefaults(self):
        if self['NUMSPECIES']== None:
            self['NUMSPECIES'] = 1
            GVars.out.put('number of species not specified, using default '\
                          'NUMSPECIES 1')

        if self['NUMMASSSCALARS']== None:
            self['NUMMASSSCALARS'] = 0
            GVars.out.put('number of mass scalars not specified, using default '\
                          'NUMMASSSCALARS 0')

        if self['GUARDCELLS']==None:
            self['GUARDCELLS'] = 4
            GVars.out.put('number of guard cells not specified, using default'\
                          ' GUARDCELLS 4')
            
    def simplify(self):
        """Store stuff that can be computed from Config info in the dictionary
        We'll use lowercase keys to separate things"""
        vars = self['VARIABLE']
        keys = vars.keys()
        #Need this since order in which a dict returns it's keys is not
        #determined.
        self['variables'] = keys

        sum = lambda x, y: x+y

        self['n_int_props']  = 0
        self['n_real_props'] = 0
        self['intproperty']  = []
        self['realproperty'] = []

        for prop in self['PROPERTY'].keys():
            if self['PROPERTY'][prop] == ('INTEGER'):
                self['n_int_props'] = self['n_int_props'] + 1
                self['intproperty'].append(prop)
            else:
                self['n_real_props'] = self['n_real_props'] + 1
                self['realproperty'].append(prop)

        self['nvar'] = self['NUMSPECIES'] + self['NUMMASSSCALARS'] + len(vars)
        self['nflux'] = self['NUMSPECIES'] + self['NUMMASSSCALARS'] + \
                                               len(self['FLUX'])

        #species are assumed to be ADVECT/RENORM/NOCONSERVE
        #mass scalars are assumed to be ADVECT/NORENORM/CONSERVE
        self['nvar_advect'] = self['NUMSPECIES'] + self['NUMMASSSCALARS'] + \
                              reduce(sum, map(lambda x, vars=vars: \
                                              'ADVECT' in vars[x], keys), 0)
        self['nvar_renorm'] = self['NUMSPECIES'] + \
                              reduce(sum, map(lambda x, vars=vars: \
                                              'RENORM' in vars[x], keys), 0)
        self['nvar_conserve'] = self['NUMMASSSCALARS'] + \
                              reduce(sum, map(lambda x, vars=vars: \
                                           'CONSERVE' in vars[x], keys), 0)


        self['var_advect_str'] = `map(lambda x, vars=vars: \
                                      int('ADVECT' in vars[x]),
                                      keys)`[1:-1]
        self['var_renorm_str'] = `map(lambda x, vars=vars: \
                                      int('RENORM' in vars[x]),
                                      keys)`[1:-1]
        self['var_conserve_str'] = `map(lambda x, vars=vars: \
                                        int('CONSERVE' in vars[x]),
                                            keys)`[1:-1]
                                            

def dumpSetupInfo(units):
    FILE1 = 'setup_call'
    FILE2 = 'setup_units'
    
    file = open(FILE1, 'w')
    for arg in sys.argv:
        file.write(arg+' ')
    file.write('\n')
    file.close()

    file = open(FILE2, 'w')
    for unit in units:
        file.write(`unit`+'\n')
    file.close()
    
def macroList(base, list):
    VAR_PER_DEFINE = 4
    NUM_OF_DEFINES = 12
    
    vars = string.split(`list`[1:-1])
    vars.reverse()

    out=''
    for i in range(NUM_OF_DEFINES):
        out = out + '%s_%d'%(base, i+1)

        if not i:
            out = out + ' /'

        for j in range(VAR_PER_DEFINE):
            try:
                out = out + ' ' + vars.pop()
                if not vars:
                    out = out + ' /'
                elif j==VAR_PER_DEFINE-1:
                    out = out + ' &'
            except IndexError:
                break

        out = out + '\n'

    return out

def runPreprocessor(flags=''):
    """Run the cpp preprocessor on all source files in current dir"""
    SUFFIXES = ['.f90', '.F90', '.f', '.F']
    ERRORFILE = 'cpperrors.log'
    TEMPFILE = 'preproc.tmp'
    import os

    sourceFiles = []
    for file in os.listdir('.'):
        if os.path.splitext(file)[1] in SUFFIXES:
            sourceFiles.append(file)

    GVars.out.put('Preprocessing source files, read %s for stderr ...' % \
                  ERRORFILE)

    for file in sourceFiles:
        os.system('( cpp %(flags)s -P -C %(file)s > %(TEMPFILE)s ) 2>>' \
                  ' %(ERRORFILE)s' % locals() )
        os.rename(TEMPFILE, file)



def linkFiles(fromdir, prevSrcFileList):
    """Link files in with right extension in fromdir to current directory.

    Note: if blah.c is in fromdir and blah.F90 is in the current directory,
    blah.F90 gets deleted. Same thing for other groups of extensions."""
    GROUPS = [['.f90', '.F90', '.f', '.c', '.F', '.C'],
                 '.py', '.fh', '.h', '_A', '.dek', '.dat', '.out', '.int', '.csh', '.rates']
    #put extensions that aren't grouped into a one-item list (save typing)
    GROUPS = map(lambda x: (type(x)==types.ListType and [x] or [[x]])[0],
                 GROUPS) 
    EXTS = reduce(lambda x,y: x+y, GROUPS)
    

    files = []
    for file in os.listdir(fromdir):
        if os.path.splitext(file)[1] in EXTS:
            files.append(os.path.join(fromdir, file))

    #sort to get consistent behavior when 2 files with equivalent extensions
    #are in fromdir    
    files.sort()
    files.reverse() 
    for file in files:
        if file in prevSrcFileList:
            #FIXME not clear how this mixes with extension grouping
            GVars.out.put('found up-to-date file %s ... not linking'%file)
            continue
        outfile = os.path.split(file)[1]
    
        base, ext = os.path.splitext(outfile)
        for group in GROUPS:
            if ext not in group: continue
            for ext2 in group:
                if os.path.exists(base+ext2): os.remove(base+ext2)

        linkCommand(file, outfile)
    return files

def linkCommand(linkFile, outFile):
    """Function serves to link files whether portable is selected or not"""
    #FIXME make links relative
    if GVars.portable:
        shutil.copyfile(linkFile, outFile)
        shutil.copymode(linkFile, outFile)
    else:
        os.symlink(linkFile, outFile)

def getInternalLib(lib):
    """Returns string to add to link line or None if the internal lib doesn't
    exist. Raises errors if internal lib exists but is troublesome"""

    USAGE = """
    Fatal Error: setup is unable to locate the internal library %(lib)s.
    In order to have setup identify an internal library, a directory
    lib/name/object must exist, where `name' is the lowercase name of the 
    library as specified with the LIBRARY directive in the relevant Config
    file. This object directory must contain an archive file
    libname.a. If libname.a does not exist in object, setup will attempt to
    build it by calling either build.py or build.csh in lib/name/source; this
    script must ultimately place libname.a in the object dir."""

    base = string.lower(lib)
    libDir = os.path.join(GVars.flashHomeDir, 'lib', base)
    if not os.path.isdir(libDir): return None, None

    objDir = os.path.join(libDir, 'object')
    binary = os.path.join(objDir, 'lib%s.a'%base)
    
    if not os.path.isfile(binary):
        pwd = os.getcwd()
        os.chdir(os.path.join(libDir, 'source'))
        if os.path.isfile('build.py'):
            GVars.out.put('exec\'ing lib/%s/source/build.py'%base)
            exec(open('build.py').read())
        elif os.path.isfile('build.csh'):
            GVars.out.put('running lib/%s/source/build.csh'%base)
            os.system('./build.csh')
        else:
            raise SetupError(USAGE%vars())
        os.chdir(pwd)

    if not os.path.isfile(binary):
        raise SetupError(USAGE%vars())

    libMacro = '-L../lib/%(base)s/object/ -l%(base)s'%vars()
    if os.path.isdir(os.path.join(libDir, 'include')):
        includeMacro = '-I../lib/%(base)s/include'%vars()
    else:
        includeMacro = ''

    return libMacro, includeMacro

def setRedirectFlags(makefile, buildFlag, libraries):
    """
    FIXME: proper documentation
    
    If the Makefile.h uses the mechanism but hasn't defined it for the given
    buildFlag (i.e., it has FFLAGS_OPT but not FFLAGS_TEST) we default to _OPT
    for whatever compilers are missing the right flag.

    Also, we have added support for "internal" libraries. If a LIBRARY
    requirement is not found in Makefile.h, then the directory
    flashHomeDir/lib/name/object is searched, where name is the name of
    the LIBRARY as specified in the Config file. If that directory exists and
    contains a file named libname.a, then Makefile has that info added to
    its LIB macro. Otherwise, setup attempts to execute a file called build.csh
    in a directory flashHomeDir/lib/name/source. This file contains commands
    for building the library and placing the library libname.a in the
    lib/name/object dir.

    Some further things to consider are adding support for multiple libraries
    within a lib directory and specifying any library dependencies.
    """
    COMPILERS = ('FFLAGS', 'CFLAGS', 'LFLAGS', 'LIB')
    DEFLTFLAG = '_OPT'

    if not os.path.isfile(makefile): text = ''
    else: text = open(makefile).read()

    #local function, returns true if the macro is defined
    haveMacro = lambda macro, text=text, re=re: \
                re.compile(r'^ *%s *='%macro, re.I+re.M).search(text)

    makefileLibs = [] #libraries defined by things like LIB_HDF4
    newDef = {}    
    for compiler in COMPILERS:
        
        newDef[compiler] = ['$(%s)'%compiler]
        for macro in [compiler+buildFlag, compiler+DEFLTFLAG]:
            if haveMacro(macro):
                newDef[compiler] = ['$(%s)'%macro]
                break
            
        for lib in libraries:
            for macro in ['%s_%s_%s'%(compiler, lib, buildFlag),
                          '%s_%s_%s'%(compiler, lib, DEFLTFLAG),
                          '%s_%s'%(compiler, lib)]:                
                if haveMacro(macro):
                    newDef[compiler].append('$(%s)'%macro)
                    if compiler=='LIB': makefileLibs.append(lib)
                    break

    #We've extracted everything we can get from the Makefile; if there are
    #some libraries we need but haven't found try to get them in lib/ directory
    for lib in libraries:
        if lib in makefileLibs: continue
        GVars.out.push()
        libMacro, includeMacro = getInternalLib(lib)
        if not libMacro:
            GVars.out.put('WARNING: A Config in your simulation requires the '\
                          'library %s, but %s does not define LIB flags for '\
                          'it AND there is no lib/%s directory.' \
                          % (lib, makefile, string.lower(lib)))
        else:
            newDef['LIB'].insert(1, libMacro)
            if includeMacro:
                newDef['CFLAGS'].append(includeMacro)
                newDef['FFLAGS'].append(includeMacro)
        GVars.out.pop()
            
    out = ''
    for compiler in newDef.keys():
        if (len(newDef[compiler])==1) and \
           (newDef[compiler][0]=='$(%s)'%compiler): continue
        macros = newDef[compiler]
        #want "main" macros like LIB_OPT to be at the end of the line
        macros = macros[1:]+[macros[0]]
        out = out + '%s := %s\n' % (compiler, string.join(macros))

    return out

def parseCommandLine(opts):
    USAGE="""usage:  simulation <problem-name> [options]

        problems: see simulations/ directory
        options: -auto -[123]d -maxblocks=<#> -nxb=<#> -nyb=<#> -nzb=<#>
                 -portable -verbose -force [-site=<site> | -ostype=<ostype>]
                 [-opt| -debug | -test | -dummy] -preprocess -objdir=<relative obj directory>
                 -with-unit=<unit> -default -fixed_block_size
"""
    
    args = sys.argv[1:]
    if (not args) or (args[0] in ['-help', '-h', '--help']):
        raise SetupError(USAGE)

    opts.simulationName = args[0]
    args = args[1:]

    reDim = re.compile(r'-[123]d$', re.I)
    reMaxblocks = re.compile(r'-maxblocks=([0-9]+)$', re.I)
    reNxb       = re.compile(r'-nxb=([0-9]+)$', re.I)
    reNyb       = re.compile(r'-nyb=([0-9]+)$', re.I)
    reNzb       = re.compile(r'-nzb=([0-9]+)$', re.I)
    reSites = re.compile(r'-site=(.+)$', re.I)
    reOstype = re.compile(r'-ostype=(.+)$', re.I)
    reObjdir = re.compile(r'-objdir=(.+)$', re.I)
    reWithUnit = re.compile(r'-with-unit=(.+)$', re.I)

    for arg in args:
        if   arg == '-portable': GVars.portable = 1
        elif arg == '-stack': opts.flashStack = 1
        elif arg == '-fixed_block_size': opts.fixedBlockSize = 1
        elif arg == '-noclobber': GVars.noClobber = 1
        elif arg == '-auto': opts.auto = 1
        elif arg == '-debug': opts.buildFlag = '_DEBUG'
        elif arg == '-test':  opts.buildFlag = '_TEST'
        elif arg == '-dummy':  opts.buildFlag = '_DUMMY'
        elif arg == '-opt':  opts.buildFlag = '_OPT'
        elif arg == '-preprocess': opts.preprocess = 1
        elif arg == '-verbose': GVars.verbose = 1
        elif arg == '-nonpermanentguardcells': opts.npg = 1
        elif arg == '-force': opts.force = 1
        
        elif reDim.match(arg): opts.dimension = int(arg[1])
        elif reMaxblocks.match(arg):
            opts.maxblocks = int(reMaxblocks.match(arg).group(1))
        elif reNxb.match(arg):
            opts.nxb = int(reNxb.match(arg).group(1))
        elif reNyb.match(arg):
            opts.nyb = int(reNyb.match(arg).group(1))
        elif reNzb.match(arg):
            opts.nzb = int(reNzb.match(arg).group(1))
        elif reSites.match(arg):
            opts.build_site = reSites.match(arg).group(1)
        elif reOstype.match(arg):
            opts.build_os = reOstype.match(arg).group(1)
        elif reObjdir.match(arg):
            opts.objectDir = reObjdir.match(arg).group(1)
        elif reWithUnit.match(arg):
            opts.withUnits.append(reWithUnit.match(arg).group(1))
        else:
            raise SetupError('%s\ninvalid option: %s'%(USAGE, arg))

# I believe these are redundant with physicaldata defaults
# consider removing
    if opts.maxblocks==None: #numbers from physicaldata.fh
        if opts.dimension==3:
            opts.maxblocks = 200            
        else:
            opts.maxblocks = 1000

    if opts.dimension < 3:
        if opts.nzb != None:
            raise SetupError("Must not specify nzb for dimensionality < 3d")
    if opts.dimension < 2:
        if opts.nyb != None:
            raise SetupError("Must not specify nyb for dimensionality < 2d")

    
    if opts.nzb == None:
        if opts.dimension > 2:
            opts.nzb = 8
        else:
            opts.nzb = 1

    if opts.nyb == None:
        if opts.dimension > 1:
            opts.nyb = 8
        else:
            opts.nyb = 1

    if opts.nxb == None:
        opts.nxb = 8



    if opts.force and opts.auto:
        raise SetupError('-force and -auto are mutually exclusive')

    if opts.flashStack:
        opts.defines.append('-DFLASH_STACK')
    
    opts.defines.append('-DN_DIM=%d'%opts.dimension)
    opts.defines.append('-DMAXBLOCKS=%d'%opts.maxblocks)

    opts.defines.append('-DNXB=%d'%opts.nxb)
    opts.defines.append('-DNYB=%d'%opts.nyb)
    opts.defines.append('-DNZB=%d'%opts.nzb)
    
def initVars(opts, GVars):
    opts.dimension = 2
    opts.defines = []
    opts.maxblocks = None
    opts.nxb       = None
    opts.nyb       = None
    opts.nzb       = None
    opts.build_site = None
    opts.build_os = None
    opts.auto = 0
    opts.preprocess = 0
    opts.fixedBlockSize = 1  #default is for blocks to be of fixed size
    opts.simulationName = None
    opts.objectDir = 'object'
    opts.buildFlag = '_DEBUG' #other options are '_DEBUG' and '_TEST' and '_OPT'
    opts.npg = 0
    opts.withUnits = []
    opts.flashStack = 0
    opts.force = 0



    #GVars is a repository for global variables.
    GVars.out = IndentedOutput()
    GVars.portable = 0
    GVars.verbose = 0
    GVars.report = 0
    GVars.noClobber = 0

def getOSType(prototypesDir):
    ostype = string.lower(sys.platform)
    if '-' in ostype:
        ostype = ostype[:string.find(ostype, '-')]
    for proto in os.listdir(prototypesDir):
        if string.count(ostype, string.lower(proto)):
            return proto
    return ostype

def getHostName(sitesDir):
    hostname = "MacOSX"                                     
    
    GVars.out.put('checking sites Aliases file')
    GVars.out.push()
    try:
        aliasLines = open(os.path.join(sitesDir, 'Aliases')).readlines()
        for line in aliasLines:
            line = stripComments(line, '#')
            line = string.strip(line)
            if line == '':
                continue
            try:
                (site, regex) = string.split(line)
                if re.match(regex, hostname) != None:
                    hostname = site
                    break
            except ValueError:
                GVars.out.put("bad Aliases file line '%s'" % string.strip(line))
    except IOError:
        GVars.out.put("couldn't open sites Aliases file")
    GVars.out.pop()
            
    for site in os.listdir(sitesDir):
        if string.count(hostname, site):
            hostname = site
    return hostname

def determineMachine(opts):
    """Returns directory of proper machine to use"""
    GVars.out.put('checking for needed files and directories')
    GVars.out.push()
    
    siteDir = os.path.join(GVars.flashHomeDir, 'sites')
    systemsDir = os.path.join(siteDir, 'Prototypes')
    ostype = getOSType(systemsDir)
    hostname = getHostName(siteDir)
   
    
    if opts.build_site:
        machDir = os.path.join(siteDir, opts.build_site)
        if os.path.isdir(machDir):
            GVars.out.put('using site directory for site '+opts.build_site)
                          
        else:
            raise SetupError('fatal:  could not find site directory for '\
                             'site %s'%opts.build_site)
    

    elif opts.build_os:
        machDir = os.path.join(systemsDir, opts.build_os)
        if os.path.isdir(machDir):
            GVars.out.put('using prototype directory for ostype '+ \
                          opts.build_os)
                          
        else:
            raise SetupError('fatal:  could not find prototype directory for '
                             'ostype ' + opts.build_os)

    else:
        machDir = os.path.join(siteDir, hostname)
        if os.path.isdir(machDir):
            GVars.out.put('using site directory for site '+hostname)
        else:
            machDir = os.path.join(systemsDir, ostype)
            if os.path.isdir(machDir):
                GVars.out.put('site directory for site '+hostname+\
                              ' not found;')
                GVars.out.put('using prototype '+ostype)
            else:
                raise SetupError('fatal:  could not find site for prototype'\
                                 ' directory!\n'
                                 '         specify site or ostype, or else '\
                                 'create a directory for your site\n\n'
                                 '         site    = %s'
                                 '\n         ostype  = %s'%(hostname,ostype))

    GVars.out.pop()
    return machDir

def getPrevSrcFileList(dir):
    out = []
    if GVars.noClobber:
        try: out = open(os.path.join(dir,'simulation_src')).read()            
        except: raise SetupError('Can\'t read simulation_src file... run without'\
                                 ' -noclobber flag')
        out = string.split(out)
    return out

def cleanObjectDir(dir):
    #keep files with the following extensions if -noclobber is used
    NOCLOBBEREXT = ['.so', '.a', '.o', '.unit', '.F90', '.c', '.fh', '.int',
                    '.py'] 

    if not os.path.isdir(dir):
        os.mkdir(dir)

    if not GVars.noClobber: #delete all files
        GVars.out.put('removing old links in build directory %s'%dir)
        for file in os.listdir(dir):
            if not os.path.isdir(os.path.join(dir, file)):
                os.remove(os.path.join(dir, file))
    else:
        #need to tell user something?
        for file in os.listdir(dir):
            if not (os.path.isdir(os.path.join(dir, file)) or \
                    (os.path.splitext(file)[1] in NOCLOBBEREXT)):
                os.remove(os.path.join(dir, file))

def createMakefiles(units, sourceDir, simulationName):
    """ Makefiles: one for each toplevel Unit. Makefiles for subunits get
    appended to the top one."""
    TEMPLATE="""#\tMakefile generated by setup for unit %(unit)s.  This Makefile is
#\tempty; if make complains about unresolved references at link time, you
#\tneed to create stub routines for this unit and create a Makefile
#\twhich sets the value of the macro $(%(unit)s) equal to the list
#\tof object files containing your stub routines.  There should be a stub
#\troutine for every routine which is called outside the unit, to be
#\tused in case the unit is not included (or in case the included
#\tsub-units of this unit do not define/override some routines).

#\tFor example, if your stub routines reside in files named stub1.F,
#\tstub2.F, and stub3.F in the %(unit)s directory, your Makefile should
#\tcontain the line
#\t\t%(unit)s = stub1.o stub2.o stub3.o

#\tFor sub-units which redefine these routines (and give the files the
#\tsame names), no additional Makefile is required.  If a sub-unit
#\tnamed \"urp\" adds another file named myfile.F, then in %(unit)s/urp
#\tcreate a Makefile containing

#\t\t%(unit)s += myfile.o

%(unit)s =
"""
    
    
    
    for unit in units:
        base = unit.name
        #print "base = " + base,
        lowestBase = getLowestBase(base)
        if not is_upper(lowestBase[0]):
            #print 'continuing'
            continue
            
        source = os.path.join(sourceDir, unit.name, "Makefile")
        target = 'Makefile.'+lowestBase
        #print 'target = ' + target
            
        if os.path.isfile(source):
            file = open(target, 'a')
            file.write(open(source).read())
            file.close()
        elif unit==lowestBase:
            file = open(target, 'w')
            file.write(TEMPLATE% vars())
            file.close()
            
            
    if os.path.isfile(os.path.join('..','simulations', simulationName,'Makefile')):
        GVars.out.put('creating Makefile link to problem simulation directory')
        linkCommand(os.path.join('..', 'simulations', simulationName, 'Makefile'),
                    'Makefile.'+simulationName)


            
            
            

            
def getLowestBase(base):

    lastGoodBase = base
    while 1:
        #if it doesn't split then...
        if not os.path.split(base)[0]:
            if is_upper(base[0]):
                return base
            else:
                return lastGoodBase
        else:   
            splits = os.path.split(base)
            #print splits
            base = os.path.split(base)[0]
            #print 'base is now ' + base + '\n'
            if is_upper(splits[1][0]):
                lastGoodBase = splits[1]
            



    return lastGoodBase
            
            
            
            
            
########################### START SCRIPT ################################
def main():
    opts = EmptyClass()
    initVars(opts, GVars)

    # the [:-4] was added here because setup.py now resides in FLASH_HOME/bin
    # to remove the /bin, we just strip off the last 4 characters.
    # this is not a very readable or robust way to do it, but it's good enough
    # for now. Should improve later
    GVars.flashHomeDir = (os.path.abspath(os.path.dirname(sys.argv[0])))[:-4]
    

    os.chdir(GVars.flashHomeDir)
    
    sourceDir = os.path.join(GVars.flashHomeDir, 'source')
    simulationsDir = os.path.join(GVars.flashHomeDir, 'simulations')

    parseCommandLine(opts)
	 
    machDir = determineMachine(opts)

    UNITSFILE = 'Units'

   
    if opts.auto:
        GVars.out.put('generating default %s file'%UNITSFILE)
	generateUnitsfile(UNITSFILE, opts)


    prevSrcFileList = getPrevSrcFileList(opts.objectDir)
    cleanObjectDir(opts.objectDir)
            
    ############## SWITCHING TO SOURCE DIR ############################
    os.chdir(sourceDir)

    simulationUnit = FlashUnit(os.path.join('..', 'simulations', opts.simulationName))

    try:
        units = []
        units = units + \
                  readInputUnitsFile(os.path.join(GVars.flashHomeDir,
                                                    UNITSFILE), opts)
    except SetupError, inst:
        #if -force, allow for nonexistent Units file.
        if not (len(inst.args)==2 and opts.force):
            raise inst

    if opts.force:
        GVars.out.put('Using units directly required by %s'%opts.simulationName)
        units = units + \
                  expandRequiredUnits([simulationUnit])
        units.remove(simulationUnit)
        units = removeParentUnits(units)

    GVars.out.put('checking for default sub-units in included units')
    
    units = expandDefaultUnits(units[:])
    units = expandParentUnits(units[:])
    units = expandKernalUnits(units[:])

    
    
    GVars.out.put('checking that no mutually exclusive sub-units '\
                  'are included together')
    checkExclusivity(units)
    checkConflicts(units)
    
    if not opts.force:
        GVars.out.put('looking for paths of non-included units')
        units = addTopUnits(units) #Ignores Config files
    units.sort()
    units.append(simulationUnit)
    if not opts.force: #Not sure if we want this or not
        GVars.out.put('checking requirements')
        checkRequirements(units[:])
    configInfo = UnitUnion(units[:])
    

    ############################### CHANGE TO OBJECT DIR ###################
    os.chdir(GVars.flashHomeDir)
    os.chdir(opts.objectDir)
    outputParameterInfo(units[:])

    #units is sorted so that subdirectories will overwrite parents' files
    file = open("simulation_src", 'aw')
   
    
    for unit in units:
        fileList = linkFiles(os.path.join(sourceDir, unit.name),
                             prevSrcFileList)
        for filename in fileList:
          file.write(filename + "\n")
    file.close()

   
    linkFiles(os.path.join(GVars.flashHomeDir, 'sites'), prevSrcFileList)

   
    linkFiles(machDir, prevSrcFileList) 

   
    linkFiles(simulationsDir, prevSrcFileList)

    #  Copy in flash.par
    if os.path.isfile(os.path.join(simulationsDir, opts.simulationName, 'flash.par')):
        shutil.copy(os.path.join(simulationsDir, opts.simulationName, 'flash.par'), '.')

    test_src = os.path.join(GVars.flashHomeDir, 'tools', 'scripts', 'testing',
                            'precision_test', 'precision_test.F90')    
    if os.path.isfile(test_src):
        shutil.copy(test_src, '.')

    GVars.out.put('creating Makefiles for all units')
    createMakefiles(units[:-1], sourceDir, opts.simulationName) #skipping simulation unit
    #FIXME merge with createMakefiles

    if opts.flashStack:
        applyFlashStack()

    GVars.out.put('generating buildstamp generator')
    generateBuildstampGenerator()

    GVars.out.put('copying release accessor function Makefile')
    shutil.copy(os.path.join(GVars.flashHomeDir, 'bin/make_release'), '.')

    GVars.out.put('copying buildstats accessor function Makefile')
    shutil.copy(os.path.join(GVars.flashHomeDir, 'bin/make_bstats'), '.')

    GVars.out.put('copying flashUnits accessor function Makefile')
    shutil.copy(os.path.join(GVars.flashHomeDir, 'bin/make_flashUnits'), '.')

    shutil.copy(os.path.join(GVars.flashHomeDir, 'bin/resetup'), '.')

    GVars.out.put('generating Makefile')
    generateMakefile(configInfo, opts, machDir)
    

   	
#    generateDbaseDefines(configInfo, opts)

    generateGridDefines(configInfo, opts)
    writeSimulation_mapVarToString(configInfo, opts)
   
    if opts.preprocess:
        runPreprocessor(string.join(opts.defines))

    dumpSetupInfo(units)    
    os.chdir(GVars.flashHomeDir)
    generateParameterCommentList(units)
#    printMemUsageGuess(configInfo, opts)
    GVars.out.put('SUCCESS')

########################### END SCRIPT #######################################
if __name__=='__main__':
    GVars = EmptyClass() #global vars, to be eliminated little by little
    try:
        main()
    except SetupError, inst:
        if inst.args: print inst.args[0]
        sys.exit(1)
    except KeyboardInterrupt:
        print '\nuser abort'
        sys.exit(1)
    except:
        print '\nA setup internal error has occured, if possible please email the following\ndebugging info to flash-bugs@flash.uchicago.edu'
        print 'Arguments:', sys.argv
        #FIXME print out machine/python info too.
        raise

